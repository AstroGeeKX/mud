指针和对象都可以访问，但指针不拥有实体。

- 一般编程设计中，不允许指针被悬挂（指向没有意义的地方），所以默认指针都指向对象地址，就没什么可担忧的了

就像访问一间房子那样，主人和客人都可以用钥匙访问房子，但主人才真正拥有这间房子。
内存内存泄漏就像是房子丢了，而不是钥匙丢了。（一般情况下指针只有8个字节，不必担心
所以释放的是对象本身，远远比指针的8个字节要多，指针一般是由系统自动管理

看一个类的声明时，通常会很关注这个变量是指针变量还是普通变量，在乎的就是，这间房子，是在类内，还是在类外。
在类外意味着这里只有8个字节大小，房子里放了一把钥匙；
在类内意味着这里不止8个字节大小，房子里塞了一间房子。
即使是指针，也有可能在构造函数创建了另一个类对象，即房子里放了把钥匙并塞了一间房子。

class Server{
private:
    Acceptor* acceptor_; // 钥匙和房子
    EventLoop* loop_; // 钥匙
    vector<string> strings_; // 房子

public:
    Server(EventLoop* loop){
        acceptor_ = new Acceptor(); // 调用构造，创建Acceptor对象
        loop_ = loop; // 这里传递对象指针，对象实例在外面的某个地方
        strings_[0] = "hello"; // 没得说
    }
}

在搞不清楚指针还是变量的最坏学习情况，最后的法子是：访问
指针和对象都可以访问，那么直接忽略内存细节，只在乎访问的功能。只在乎代码是如何使用这个类的元素的，成员变量或成员函数。
因为一个类里面有另一个类的指针或对象，起到的作用是成员访问和内存管理。

成员访问，A类里面有B类指针，要访问B类里面的成员函数，来达到一些功能
内存管理，A类里面有B类对象，甚至是多个，A类为B类设计了一些函数来创建和删除B类


#### 关于构造函数里的鸡肋参数
```cpp
Server::Server(EventLoop *_loop) : mainReactor(_loop), acceptor(nullptr){ 
    acceptor = new Acceptor(mainReactor);
```
第二行是简单创建一个Acceptor对象，_loop通过函数传参，赋值到mainReactor，所以Acceptor的mainReactor等同于_loop，这个传参只是访问需要。
Server()构造函数传参_loop，原因很简单，只是因为函数内部有访问的需要（作为Acceptor的参数）。不像设计模式那样，每个传参可能对整体结构具有决定性的意义。

#### 试着去除所有的优化，以降低整体逻辑的复杂度
如果觉得有些内容散布太多不易理解，就像是传参优化，就可以重新写一份代码，去除所有的优化，使整体逻辑更清晰。在这个过程中，就会无意中理清很多优化的地方，有强烈的对比，就更容易学会了。现在不同于初学阶段，学习内容更多，任务更重，要做的是返璞归真，从简单开始着手，其次才生吃，这样才能做到专注有效内容，不被各种噪音干扰。初学阶段追求复杂是为了提升认知，提升专业程度，现阶段的目的并不是这些，所以需要灵活变通，修整策略。



## 天工AI
您提到的这个现象在C++中确实很常见，尤其是在设计面向对象的程序时。在C++中，指针（包括智能指针）和引用（references）是管理对象间关系的重要工具。理解何时使用指针、何时使用引用，以及何时拥有（own）一个对象与仅访问（access）一个对象的区别，是高级C++编程的关键。

### 拥有 vs. 访问

- **拥有（Ownership）**：当一个对象直接持有另一个对象的实例时，我们说前者拥有后者。这意味着对象的生命周期与所有者相关联。当所有者销毁时，它拥有的对象也会被自动销毁。在C++中，这通常通过对象成员的直接实例化来实现，如`EventLoop event_loop_;`，或者通过智能指针如`std::unique_ptr`来管理。

- **访问（Access）**：当一个对象需要与另一个对象交互，但并不控制其生命周期时，我们说前者访问后者。这通常通过指针（裸指针或智能指针如`std::shared_ptr`）或引用实现。在您提供的`Channel`类例子中，`EventLoop *loop_;`就是这样的场景，`Channel`类通过`loop_`指针访问`EventLoop`的资源，但不拥有它，因此`Channel`的生命周期不影响`EventLoop`。

### 用什么类型的指针

- **当需要拥有对象时**：直接实例化对象或者使用智能指针，以确保资源的自动管理。

- **当需要共享资源时**：使用`std::shared_ptr`等智能指针，这可以自动管理资源的生命周期，当最后一个引用消失时，资源会被自动释放。

在您的例子中，`Channel`类使用`EventLoop *loop_;`裸指针，表明`Channel`需要与`EventLoop`交互，但不控制其生命周期，这是一种典型的访问而非拥有的关系。这在多对象交互且生命周期独立的系统中非常常见，如网络编程、事件驱动的系统等。