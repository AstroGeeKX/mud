这里是day16的笔记。
之前章节的内容看得很粗糙，这是最后一天的教程，更完整地记录了代码阅读笔记。


### 分清Acceptor和Connection的职责
这两个有点像，最讨厌的就是名称和内容不相符，甚至混淆。
- Acceptor是创建和管理新的客户端套接字，包括ip端口和sockfd等。主要表述动作，接受
- Connection则是把这些套接字结合Channel封装成更完整的单元，还包括了数据读写的操作。主要表示名词，连接
这下就显而易见了，Acceptor是简单的创建套接字，像一个士兵，后者Connection是在套接字的基础上进一步封装，使其具备更多行为，包括阻塞/非阻塞读写函数。相当于给单兵作战的士兵每个人配备了一台无线电。
Connection里有很多个阻塞/非阻塞，读/写函数。
在程序中运行中会实例化很多个对象，代表多个客户端连接对象。
C++基础：成员函数不占对象空间，非静态数据成员才占用空间。


### TcpServer的职责
之前这个类叫做Server，现在变成了TcpServer。
首先，这并不用于创建TCP连接，而是初始化和管理整个程序的主体框架，
per thread per loop的Reactor网络模型的程序框架。
涉及到主线程、从线程、线程池、接受器、连接对象、用户自定义事件处理、
- 构造函数：初始化主线程、接受器、从反应器等
构造EventLoop事件循环和Acceptor接受器对象，为Acceptor对象设置回调函数TcpServer::NewConnection()，构造ThreadPool线程池对象，创建CPU允许最大数量的子线程，再构造相同数量的EventLoop对象作为从反应器，将从反应器对象存入sub_reactors_容器。
- Start()函数：正式启动主反应器和从反应器
所有sub_reactors_里的对象绑定this指针和Loop()函数为可调用对象，全部加入线程池任务队列中，线程池会自动执行这些事件循环，每一个线程正好能分到一个事件循环。
随后有一行代码手动启动主反应器，main_reactor_->Loop()，主反应器运行在主线程上，其他的从反应器都运行在线程池开辟的子线程上。
- NewConnection()函数：创建新连接
这是监听套接字的事件处理，也是配合Acceptor::AcceptConnection()完成连接对象创建的函数。首先创建套接字之后，创建connection对象，随机哈希到某个从线程里，这个connection之后的一切监听和事件行为均在这个线程中完成。以此实现高并发和负载均衡。
- DeleteConnection()函数：删除
给定fd，从connection_字典中删除对应的conn单元。操作通常由connection对象完成，所以作为connection对象自己的回调函数，在事件循环中侦测到tcp网络连接关闭的时候，进行自我删除。（conn调用成员回调函数，实则是间接调用了这里）。
- onConnect()：设置用户自定义客户端新连接时的事件处理
这是公有成员函数，在应用程序代码中使用。用户在应用程序写了自定义的事件处理之后，封装成function<>对象，传递进这个函数，然后移动拷贝到本类的成员变量on_connect_里存储。
这是自定义新建客户端连接事件的事件处理
- onRecv()：设置用户自定义接收客户端信息时的事件处理
这是自定义客户端读事件的事件处理，编写应用程序时以lambda等方式将函数传递进来，网络库内部会关联此操作，到相应的事件处理上，比如这里设置打印连接信息，那么在每次新连接的时候，都会有信息打印。

#### on_connect_回调函数
on_connect的意思是，在新连接客户端时的事件处理。
```c++
  if (on_connect_) {
    on_connect_(connections_[fd].get());
  }
```
```c++
  server->onConnect([](Connection *conn) { std::cout << "New connection fd: " << conn->socket()->fd() << std::endl; });
```
上面的函数的一部分代码，是实现用户自定义功能的地方。打印新连接客户端的消息。
用户可以写，也可以不写，如果写了，if语句判断是有东西的，那么调用。
创建客户端新连接是监听套接字的事件处理，仔细想想，既然是事件处理，那么用户就可以自定义事件处理函数，也就是在应用程序中写到OnConnect(function<> &fn)函数里的lambda函数。首先创建新连接是固定的必要实现，可以加上用户的自定义事件处理。
对比客户端套接字的事件处理，可能只有简单的读写和打印输出，没有新建连接的步骤。
- 客户端套接字事件处理：Read() + OnConnect()
- 服务器套接字事件处理：AcceptConnection() + OnConnect()

#### on_recv_回调函数
on_recv_的意思是，读类型事件时候的事件处理。
```c++
// 这是应用程序的代码片段 自定义客户端套接字读事件处理
server->onRecv([](Connection *conn) {
    std::cout << "Message from client " << conn->read_buf()->c_str() << std::endl;
    conn->Send(conn->read_buf()->c_str());
  });
```
我在想怎么区分新建客户端连接的事件处理，和接受客户端消息的事件处理。
一般说的是读类型事件。服务器套接字的事件处理是**新建客户端连接**，客户端套接字的事件处理是**读写数据**
在应用程序代码中可以看到，lambda函数里直接打印了来自客户端的消息，并且重新发送回去，形成一个echo回声。
这里没有Read()函数，是因为读函数在内部已经调用了，用户自定义的内容，是承接读函数之下，进行打印信息，并且再把消息发送回去。具体的实现是在Business()函数里，用户自定义事件处理on_recv_紧跟着Read()函数，真正设置到Channel里面的事件处理是Business()函数，将两者进行打包的细节不说了。
```c++
void Connection::Business() {
  Read();
  on_recv_(this);
}
```
不管怎么说，即使明白了整体的意图，但还是很难看清晰这些事件处理回调函数的过程，因为很绕。有耐心可以仔细看。


### EventLoop类的职责
这是事件循环的类封装，核心功能是Loop()函数。
外层循环监听事件，内层循环遍历并处理每一个就绪事件，如此反复。
就绪事件的处理是对sockfd进行读/写操作，基于socket，和操作系统的io多路复用机制无关，因此不涉及系统平台的代码将其职责分离，起到跨平台的作用。获取就绪事件的代码在Poller类里。
另外，这里具体的操作单元是封装好了的Channel对象而不是简单的sockfd。

#### 构造函数EventLoop()
```c++
EventLoop::EventLoop() { poller_ = std::make_unique<Poller>(); }
```
构造函数以智能指针的形式创建一个Poller对象，存放在私有数据成员里，用在事件循环里获取就绪事件。原本EventLoop类里负责监听事件和处理事件，为了跨平台和解耦合，把监听功能转移到Poller类，这里只保留处理事件。在Poller类里，会根据操作系统的宏定义选择相应的机制，具体需要对Linux和MaxOS等系统各实现一份监听代码。

#### EventLoop::Loop()函数
这个函数是此类的核心功能，是事件循环的主体代码。
```c++
void EventLoop::Loop() const {
  while (true) {
    for (Channel *active_ch : poller_->Poll()) {
      active_ch->HandleEvent();
    }
  }
}
```
短短的几行代码能清晰的看到事件循环的全貌。外层一个while死循环，内层是for循环，大循环执行事件监听和处理。事件处理使用foreach新特性使代码看起来简洁明了。
首先执行poller_->Poll()函数，返回值是vector<Channel* >类型，遍历每一个元素，进行处理HandleEvent()。
获取就绪事件，遍历所有的元素，就完成了一轮事件的监听和处理。

#### UpdateChannel()和DeleteChannel()函数
这两个函数用于更新和删除Channel
更新是对**监听事件类型**的更新。
删除是将某个事件从监听列表里删除。
```c++
void EventLoop::UpdateChannel(Channel *ch) const { poller_->UpdateChannel(ch); }
void EventLoop::DeleteChannel(Channel *ch) const { poller_->DeleteChannel(ch); }
```
这两个函数里调用了poller_对象里名称相同的函数，可以看得出具体的实现是在Poller类里面。所以下面直接讲解Poller类的成员函数。
- 更新
update的意思不只是update，除了更新，同时包括了添加事件。
函数判断如果该事件未添加，那么添加，如果已添加，那么修改。
对应EPOLL_CTL_ADD和EPOLL_CTL_MOD操作
```c++
epoll_ctl(fd_, EPOLL_CTL_ADD, sockfd, &ev) // 添加
epoll_ctl(fd_, EPOLL_CTL_MOD, sockfd, &ev) // 修改
```
- 删除
比较符合函数名称的功能，从监听列表中删除channel。具体的细节是，先从channel对象中获取sockfd，根据这个sockfd从监听列表中删除，然后再调用SetExist(false)设置ch不在监听列表里。
```c++
void Poller::DeleteChannel(Channel *ch) {
  int sockfd = ch->GetSocket()->fd(); // ch->GetSocket()返回Socket对象指针 fd()返回sockfd
  ErrorIf(epoll_ctl(fd_, EPOLL_CTL_DEL, sockfd, nullptr) == -1, "epoll delete error");
  ch->SetExist(false); // 设置ch不存在监听列表里
}
```
使用epoll_ctl()函数从监听列表中删除监听事件，这是基本的操作。


### Poller类的职责
这个类是IO多路复用机制的一个行为封装类，核心功能是**监听就绪事件**。
epoll基础操作包括监听就绪事件和处理就绪事件，其中监听事件的职责转移到了Poller类中。
核心功能是Poll()函数，返回值是就绪事件channel对象的集合，传递到EventLoop::Loop()中进行事件处理

#### 构造函数Poller::Poller()
程序运行中，Poller对象在EventLoop的构造函数里进行一次构造。
Poller()构造函数调用epoll_create1()函数创建了epoll文件描述符，类似于现代c++的对象实例，是epoll的基础操作。还new了epoll_event[MAX_EVENTS]数组，以指针的方式存放在私有数据成员，memset()初始化内存为空。

#### 析构函数Poller::~Poller()
析构函数至少要知道delete释放掉new开辟的空间
遵循《Effective C++》中的条款，delete跟随new的形式是否带方括号 delete[] events_;
还有一个epollfd关闭的操作 close(fd_);

#### Poll()函数
此函数的核心功能获取就绪事件，核心操作是 epoll_wait() 函数。
首先获取就绪事件列表，返回值是就绪事件的数量nfds，就绪事件写到events_数组里。这里的具体细节是，遍历每一个元素，获取就绪事件以及类型，存放到channel对象里，再逐一装入vector<Channel*>容器里，以返回值的形式传递到函数的调用处，也就是EventLoop::Loop()函数，在这里进行事件处理。
从原始的epoll_event结构体到高级的Channel类拆解和封装，是为了上层能够高级抽象地编程，更好实现。

#### UpdateChannel()和DeleteChannel()函数
这两个函数上面已经讲解过了，是用来更新和删除Channel对象的。
EventLoop类里面也有名称完全相同的函数，只不过是空壳，里面只有一行语句调用了这两个函数。
前者处理channel监听类型的更新（也包括了添加到监听列表），后者是将事件从监听列表中删除。
可以说Channel充当了事件数据的载体，是高级封装。相当于epoll机制里的epoll_event结构体。


### Acceptor类的职责
- 首先要知道epoll机制，服务器套接字的事件处理是创建新客户端连接，客户端套接字的事件处理才是读写数据
构造函数创建了服务器套接字（监听套接字），类的核心功能创建新的客户端连接是AcceptorConnection()函数，此函数作为监听套接字的事件处理，有新的客户端连接时，调用此函数，创建新的客户端连接。
这个类原本只用于接受新的客户端连接，具体一点只是创建客户端的sockfd。但内部调用了一个回调函数，依次创建Connection、Channel对象等，使得整个客户端连接对象的创建过程完整实现。

#### 构造函数Acceptor::Acceptor()
创建服务器套接字（监听套接字），创建此套接字的Channel对象，设置事件处理为AcceptConnection()函数。服务器接字不同于客户端套接字，有事件发生时，代表有新的客户端连接，需要创建客户端的套接字，客户端套接字的事件处理才是读写数据等操作，这是epoll机制的内容。
首先构造一个Socket对象，依次调用对象的Create() Bind() Listen()函数来创建和初始化服务器套接字。然后用这个sockfd构造Channel对象，作为事件的封装，这个对象叫做监听套接字事件（与之对应的是客户端套接字事件），设置此事件的读事件的事件处理为AcceptConnection()函数。

#### AcceptConnection()函数
这个函数为新客户端连接创建套接字，核心功能是Accept()函数。随后设置该clnt_fd套接字为非阻塞，再调用更多创建新连接相关的函数new_connection_callback_(clnt_fd)，这是个回调函数，里面涉及比较多的高级封装对象的创建，在这里大致描述一下。

#### std::function<void(int)> new_connection_callback_ 回调函数
Acceptor类只负责创建套接字，其余更多管理连接的对象由这个回调函数完成创建。
这是一个私有数据成员，旨在绑定TcpServer::NewConnection(int fd)函数，在Acceptor::AcceptConnection()里面调用。创建Connection对象、Channel对象等，并将Connection对象放入connectons_容器里，设置相关的回调函数、Channel的事件处理等内容。
new_connection_callback_绑定的回调函数是TcpServer::NewConnection()函数，这个函数里先random随机一个从线程的位置，然后调用Connection构造函数创建对象，这个函数里面根据从前面传进来的fd构造Socket对象，然后再构造Channel对象，Connection()构造完毕，退栈到TcpServer::NewConnection()函数以完成后续的conn对象的相关设置，把conn移动拷贝进connections_容器里。至此，以上函数调用完成，回到最初的AcceptConnection()函数，返回成功的标志，结束整个过程。
- Acceptor::AcceptConnection() -> TcpServer::NewConnection(int fd) -> Connection::Connection(int fd, EventLoop *loop)
一个客户端连接需要构造的几个数据对象是Socket对象 Channel对象 Connection对象，依次在里面完成构造，虽然函数转跳有些混乱，但这也挺符合面向对象编程的一般印象。


### Connection的职责
这个类是客户端连接对象的封装，包含了Socket和Channel对象在内，还有基本的读写函数的实现。

#### 封装了Socket和Channel的对象作为私有数据成员
服务器处理监听套接字的事件时，实例化一个新的Connection对象代表一个客户端连接，程序运行过程中会实例化若干个这样的对象，具体的创建过程是在TcpServer::NewConneciton()函数里。每一个Connection对象有一个Socket对象，没有必要用原始的socketfd了，另外还有一个Channel对象用于管理事件，比如监听和处理事件。两者整合成为一个更抽象，更高级，更易用的客户端连接封装。
这个封装使得客户端连接对象具备管理套接字和事件的职能，是一个客户端连接应该具备的基本职能。

#### 封装了Read读和Write写的操作
这两个io操作看起来是很简单的基本操作，但实际上是网络通信的核心操作。
仔细想想，要进行通信，那么就有对数据的读和写。
阻塞/非阻塞 读/写一共四个函数各实现一遍。再进行封装一层，变成更简洁的Read()和Write()。
函数里判断该套接字是阻塞还是非阻塞，调用相应的函数来处理，真正的实现在前面四个函数。
```c++
  RC ReadNonBlocking(); // 非阻塞读
  RC WriteNonBlocking(); // 非阻塞写
  RC ReadBlocking(); // 阻塞读
  RC WriteBlocking(); // 阻塞写

  RC Read(); // 读 阻塞和非阻塞的封装
  RC Write(); // 写 阻塞和非阻塞的封装
```

#### Business()函数
这个函数是读事件的事件处理，大概是因为读数据是网络编程中较为常用的操作，所以命名为一个通用“Bussiness”，用户自定义事件处理on_recv_跟在Read()函数下边，用户可以也可以不定义on_recv_，Business()函数里面至少有一个Read()函数，做到灵活多变的编程。
当然，这个函数的功能已经在TcpServer那一段结合on_recv_介绍过了。
```c++
void Connection::Business() {
  Read(); // 这是关键点，读事件处理
  on_recv_(this); // 用户自定义事件处理
}
```

#### 两个Buffer作为读和写的缓冲区
这两个数据成员代表读写缓冲区，在实例化Coneciton对象的时候，会为这些数据成员开辟内存空间。
在构造函数中make_unique，所以生命周期将伴随整个对象。
```c++
  // 私有数据成员声明
  std::unique_ptr<Buffer> read_buf_; // 读缓冲区
  std::unique_ptr<Buffer> send_buf_; // 写缓冲区

  // 构造函数里创建对象
  read_buf_ = std::make_unique<Buffer>();
  send_buf_ = std::make_unique<Buffer>();
```

#### 状态码枚举类型
创建了一个枚举类型代表各个状态，在通常在返回值中使用，表示当前的连接状态。
也会在一些函数中使用，比如读写函数，会首先判断连接是否关闭，再进行读写。判断的位置应该遵循最佳实践，放到合理的地方，即使放到不合理的地方也能运行。
下面是State的定义和在读写函数中的应用
```c++
// "Connection.h" 公有数据成员
  enum State {
    Invalid = 0, // 不合法
    Connecting, // 连接中
    Connected, // 已连接
    Closed, // 关闭
  };
// "Connection.cpp" Read()函数
RC Connection::Read() {
  if (state_ != State::Connected) {
    perror("Connection is not connected, can not read");
    return RC_CONNECTION_ERROR;
  }
  assert(state_ == State::Connected && "connection state is disconnected!");
  // 读写的具体实现...
}
```

#### 总结Connection类
总的来说Connection类代表了客户端连接对象的封装，包括了套接字、io多路复用机制、读写函数、读写缓冲区等内容，是整合了Socket和Channel更抽象更概括的封装，更适合用户直接使用。


### Channel类的职责
Channel可以看作事件的一个中间层封装，原始的struct epoll_event结构体太生硬了。
每一个Channel对象携带一个客户端sockfd变量。
epoll机制是以epoll_event结构体对象的方式管理事件，主要的内容是sockfd套接字文件描述符和事件类型event，封装成Channel对象，更方便操作。
channel对象地址放到ev.data.ptr指针上作为绑定，再将结构体对象ev挂到红黑树上。

#### 构造函数 Channel::Channel(int fd, EventLoop *loop)
构造函数有两个参数，一个套接字文件描述符，一个EventLoop指针，套接字是重中之重，因为事件就绪和处理面向的就是套接字文件描述符。loop对象保存到类的私有数据成员，主要用来访问UpdateChannel()函数和DeleteChannel()函数。
一般情况下，另一个类对象的指针传参进构造函数，大概是用来起访问成员函数的作用，而不是管理资源，这需要进阶的编程技术来认知。

#### 析构函数Channel::~Channel()
```c++
Channel::~Channel() { loop_->DeleteChannel(this); }
```
析构函数里有一行函数调用，EventLoop类loop_对象里的DeleteChannel()函数，从epoll监听列表中删除。其实我不太理解为什么需要这样的操作，应该是后续连接断开的时候，需要析构Channel，顺带从监听列表中删除。可是这些操作为什么不由Connection类来管理呢。

#### HandleEvent()函数
这是事件处理函数。
```c++
void Channel::HandleEvent() const {
  if (ready_events_ & READ_EVENT) {
    read_callback_();
  }
  if (ready_events_ & WRITE_EVENT) {
    write_callback_();
  }
}
```
在事件循环中，获取了就绪事件之后，调用这个函数处理事件。判断事件的就绪类型，执行相应的事件处理，比如读或者写事件。
ready_events_是私有数据成员，这个类型会在事件就绪时变化。在Poll()获取就绪事件的时候，把就绪事件的类型修改，处理事件的时候就可以直接使用了。回忆一下不经过Channel封装的原始操作过程，是events结构体数组里面的某一个元素，里面的events参数，代表就绪事件类型。

#### EnableRead() EnableWrite() EnableET()函数
这三个函数设置监听事件类型，分别是开启读、写、边沿触发模式。
函数内部首先设置这样listen_events_ |= READ_EVENT（读类型），然后调用loop_->UpdateChannel(this)函数

#### set_read_callback() set_write_callback()函数
这两个函数用来设置事件处理函数，分别是读和写事件的事件处理。
```c++
  std::function<void()> read_callback_;
  std::function<void()> write_callback_;
```
可以看到这两个是function<>封装的可调用对象，使用晚绑定的机制，灵活设置事件处理具体实现。
在应用程序中，用户自定义了事件处理，封装成可调用对象，经过了几个类的传递，最终保存到Channel里，这里事件处理函数真正的落脚点。

#### listen_events_和ready_events_数据成员
这两个数据成员代表**监听事件类型**和**就绪事件类型**。
分别在需要的地方进行设置，具体的设置过程有些繁琐，涉及到epoll机制的事件类型宏，还有|=和&等运算符，过程比较复杂，所以这里略过。


### Socket类的职责
这是对socket套接字的封装，内容和套接字编程基本一致，名称上也只是首字母大写的区别。
核心功能函数是Create() Bind() Listen() Accept() Connect()。
其余还有set_fd() fd() get_addr() SetNonBlocking() IsNonBlocking() RecvBufSize()函数。
这些函数用于设置fd、获取fd、获取ip地址、设置非阻塞、判断非阻塞、获取收到的字节数。

#### 构造函数和析构函数
```c++
// 构造函数
Socket::Socket() : fd_(-1) {}
```
- 构造函数十分的简单，只是初始化了套接字文件描述符fd为-1。
这里我想到了一些内容，即RAII原则，初始化的过程统一在构造函数里，不是在声明数据成员的时候，这样就能清晰地管理数据的初始化，避免定义位置不一致，造成意义不明确。
```c++
// 析构函数
Socket::~Socket() {
  if (fd_ != -1) {
    close(fd_);
    fd_ = -1;
  }
}
```
- 析构函数同样遵循RAII原则，构造函数初始内存，析构函数销毁内存，前后呼应，意义明确。
调用close()是对文件描述符的操作，不是socket特有的，例如epollfd也是用close()来关闭
这是对于Linux系统文件的操作。

#### set_fd()和fd()函数
设置fd和获取fd，函数体只有一行语句。
```c++
void Socket::set_fd(int fd) { fd_ = fd; } // 设置套接字fd
int Socket::fd() const { return fd_; } // 获取套接字fd
```


### ThreadPool类的职责
这个线程池是通用的，和网络库关联不大，下面简单对其解析。

#### 构造函数
```c++
// "ThreadPool.h"
explicit ThreadPool(unsigned int size = std::thread::hardware_concurrency());

// "ThreadPool.cpp"
      while (true) {
        std::function<void()> task;
        {
          std::unique_lock<std::mutex> lock(queue_mutex_);
          condition_variable_.wait(lock, [this]() { return stop_ || !tasks_.empty(); });
          if (stop_ && tasks_.empty()) {
            return;
          }
          task = tasks_.front();
          tasks_.pop();
        }
        task();
      }
```
构造函数先创建CPU支持最大数量的线程，每一个子线程里是一个死循环，反复从任务队列中获取任务并执行。
在网络库中，一个从反应器由一个子线程运行，而从反应器是个自循环，所以整个程序周期，子线程任务不变。
固定执行事件循环。

#### 析构函数
```c++
ThreadPool::~ThreadPool() {
  {
    std::unique_lock<std::mutex> lock(queue_mutex_);
    stop_ = true;
  }
  condition_variable_.notify_all();
  for (std::thread &th : workers_) {
    if (th.joinable()) {
      th.join();
    }
  }
}
```
析构函数把所有的子线程join()销毁。
互斥锁把stop_上锁，设置为true，再通知notify所有线程，将所有的子线程销毁。


### Buffer类的职责
这是缓冲区的封装，就是简单用std::string来实现容量动态变化，封装一些读写操作以更方便地使用。
内容比较简单，可以轻松动手实现。

#### 类的整体声明
内容不多，于是把类的全部声明放到了这里。可以耐心看看。
构造函数是默认构造函数 Buffer() = default;
析构函数也是默认析构函数 ~Buffer() = default;
核心是私有数据成员 std::string buf_;
Size()用来返回字节大小 Append()用来增加内容在结尾 Clear()用来清空内容
c_str()将字符串以char*类型返回，相当于get函数
毕竟这是一个Buffer类，不能直接当成字符串使用。

```c++
// "Buffer.h"
class Buffer {
 public:
  DISALLOW_COPY_AND_MOVE(Buffer);
  Buffer() = default;
  ~Buffer() = default;

  const std::string &buf() const;
  const char* c_str() const;
  void set_buf(const char *buf);

  size_t Size() const;
  void Append(const char *_str, int _size);
  void Clear();

 private:
  std::string buf_;
};
```


### 总结
其实大可不必去仔细思考有些操作为什么在那些地方。在总览了整个源码之后，所有的职责都已经划分整齐，物尽其用，这就已经达到封装一个网络库的目的了，已经达到能run的目的了。这些细节为什么这样，这就算是开发者个人脑洞的事情，不必关心太多。
