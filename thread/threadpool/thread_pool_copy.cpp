#include <iostream>
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <functional>

// 定义一个线程池类，用于管理一组工作线程，自动分配任务。
class ThreadPool {
public:
    // 构造函数，初始化线程池，创建指定数量的线程，数量用threads表示。
    ThreadPool(size_t threads) : stop(false) {
        // 循环创建工作线程，并将其加入到工作线程列表中。
        for (size_t i = 0; i < threads; ++i) {
            // 创建线程，执行成员函数worker_thread。
            // 每个线程都开始执行worker_thread，并传入this指针，以便在线程函数中访问类的成员。
            workers.emplace_back(&ThreadPool::worker_thread, this);
            // 一下是上一行代码的解析 涉及了参数转发等内容，调用的是元素类型本身的构造函数，即thread()
            // 绑定的任务不同，一般情况是独立的函数对象，这里是类的成员函数，需要携带this指针
            // auto task = std::bind(&ThreadPool::worker_thread, this);
            // workers.emplace_back(task);
        }
    }

    // 析构函数，用于在销毁对象时，确保所有工作线程都能正确地结束。
    ~ThreadPool() {
        // 设置stop标志为true，指示所有工作线程应该停止执行。
        stop = true;
        // 通知所有等待的工作线程，让它们检查条件变量。
        cv.notify_all();
        // 等待所有工作线程结束。join是阻塞等待线程结束
        // 每一个worker都是一个thread实例对象 里面绑定的任务是worker_thread()函数，这命名很迷惑
        for (std::thread &worker : workers) {
            worker.join();
        }
    }

    // 提交任务到线程池，由线程池中的某个线程执行。
    void submit(std::function<void()> task) {
        // 锁定互斥量，以保护任务队列。
        std::unique_lock<std::mutex> lock(queue_mutex);
        // 将任务添加到任务队列中。
        tasks.emplace(std::move(task));
        // 解锁互斥量，因为接下来的操作不涉及共享资源。锁上代表其他使用queue_mutex的线程被阻塞
        // 是一种主动的协调机制，而不是被动的单方面地独占访问权
        lock.unlock();
        // 通知一个等待的工作线程，有新任务可以执行了。
        cv.notify_one();
    }

private:
    // 工作线程列表，存储所有的工作线程。可以看到thread线程对象用vector容器装起来
    std::vector<std::thread> workers;
    // 任务队列，存储待执行的任务。可以看到可调用对象用queue装起来，是函数、lambda表达式、function<>等
    // 任务就是thread对象绑定的那个执行的任务，基础教程中是放入函数指针进行绑定
    std::queue<std::function<void()>> tasks;

    // 互斥量，用于同步对任务队列的访问。
    // 如果有多个线程对任务队列加入新函数，资源竞争，就有可能导致queue队列数据损坏
    // 但这里的代码没有体现，因为只有一个main主线程调用了submit函数
    std::mutex queue_mutex;
    // 条件变量，用于工作线程在没有任务时等待，以及有新任务时唤醒。
    // 起等待唤醒的作用，针对的是queue是否为空，没有工作做了，自然就休息了
    std::condition_variable cv;
    // 控制线程池停止的标记。这是一手停止所有线程里while()循环的机制，是while(!stop){}循环的条件
    bool stop;

    // 工作线程执行的函数，不断从任务队列中取出并执行任务。
    // 放置若干个酿造台，是创建了多少个工作线程；要处理多少任务，是你的朋友让你炼制多少药水
    // 这里是类内函数，从任务队列中取出一个任务并执行，多少个worker_thread线程就类似mc中放置了多少个炼药炉
    // 经过外界的submit()，任务队列有任务（类型是function<void()>)了之后，线程循环才能从任务队列中获取一个任务
    void worker_thread() {
        while (true) {
            std::function<void()> task;
            {
                // 上锁并等待条件变量，直到有任务可执行或线程池停止。
                // unique_lock是锁管理，其实可以直接queue_mutex.lock()
                std::unique_lock<std::mutex> lock(queue_mutex);
                // wait的第二个参数是lambda表达式，为假卡住，任务队列空卡住
                cv.wait(lock, [this]{ return stop || !tasks.empty(); });
                // 如果线程池停止且任务队列为空，退出循环，结束线程。
                // 唤醒有两种情况，一是任务有了唤醒，二是执行析构函数stop为真了唤醒，短路求后者
                if (stop && tasks.empty()) return;
                // 取出队列中的第一个任务。这里tasks是queue容器，互斥锁防的是这里，还有wait里的tasks.empty()
                task = std::move(tasks.front());
                // 从队列中移除任务。
                tasks.pop();
            }
            // 执行任务。
            task();
        }
    }
};

// 主函数，程序的入口点。
int main() {
    // 创建一个包含4个工作线程的线程池。
    ThreadPool pool(4);

    // 提交两个任务到线程池。
    pool.submit([](){
        std::cout << "Task 1 is running" << std::endl;
    });

    pool.submit([](){
        std::cout << "Task 2 is running" << std::endl;
    });

    // 主线程等待1秒钟，让提交的任务有时间去执行。
    std::this_thread::sleep_for(std::chrono::seconds(1));

    // 程序结束。
    return 0;
}

空闲 = 挂起
// stop为真 并且 任务列表清空 线程才能退出
notify_all()通知只针对挂起的空闲线程
// 任务不空 所有线程忙碌 通知无用 任务清空 忙碌线程完成任务逐一退出
// 没有任务 所有线程忙碌 通知无用 忙碌线程完成任务逐一退出
// 没有任务 部分线程空闲 通知空程 空程退出 忙碌线程完成任务逐一退出
// 没有任务 线程空闲 通知所有 集体统一退出
通知只针对空闲线程 全部空闲或部分空闲
存在空闲线程的情况，任务列表必然为空


// 条件变量逻辑困难
// cv.wait(lock, [this]{ return stop || !tasks.empty(); });
// 条件变量的逻辑是：真就过 假就等
cv.wait()真代表继续任务
tasks.empty()假代表继续任务
使相同目的逻辑值统一就行，通过后者逻辑值是否取反!来统一




///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/*  天工AI解析 有用的解析 有用的解析 有用的解析 有用的解析 有用的解析 有用的解析 有用的解析

您的理解是正确的，`worker_thread` 函数是线程池中工作线程执行的主循环，其逻辑可以分成几个关键部分：

1. **循环检查**：`while (true)` 构成了一个无限循环，这意味着工作线程会持续运行，直到收到停止信号。

2. **任务检索**：在循环内部，首先声明了一个 `std::function<void()> task` 变量，用于存储从任务队列中取出的任务。

3. **上锁和等待**：
   - 使用 `std::unique_lock<std::mutex>` 上锁，保护对共享资源（任务队列和条件变量）的访问。
   - `cv.wait` 是条件变量的等待调用，它使得线程在没有任务可执行（队列为空）且线程池未停止时挂起。它等待一个通知（由 `submit` 函数发出），或者线程池停止信号。

4. **任务执行**：
   - 检查 `stop` 标志和任务队列是否为空。如果线程池已被标记停止且没有剩余任务，线程将退出循环，结束执行。
   - 如果有任务或线程池未停止，线程从队列中取出（`std::move(tasks.front())`）并移除（`tasks.pop()`）一个任务。

5. **执行任务**：在锁外执行 `task()`，因为执行任务通常不需要访问共享资源，这样可以减少锁的持有时间，提高效率。

6. **循环继续**：任务执行完毕后，循环回到开始，继续检查并执行下一个任务。

这种设计确保了工作线程在有任务时忙碌执行，在无任务时高效等待。使用条件变量 `cv.wait` 是多线程编程中常用的一种模式，用于实现线程间的同步和通信。它允许工作线程在没有任务时挂起，减少 CPU 资源的浪费，同时在新任务到来时迅速响应。

此外，通过在 `std::unique_lock` 的作用域外执行任务，可以减少锁的持有时间，避免在执行任务时长时间占用锁，这有助于提高线程池的整体并发性能。


问题一：关于 `join()` 的行为

`std::thread::join()` 的确是用来阻塞调用它的线程（通常是主线程），直到线程对象所代表的线程执行完成。这里的“阻塞”不是指阻塞子线程，而是指阻塞调用 `join()` 的那个线程（可能是主线程或其他线程）。在多线程编程中，`join()` 是一种同步机制，用来等待线程结束，确保线程的执行顺序或者在程序退出前完成所有子线程的工作。

### 为什么 `join()` 会阻塞？

- **同步**：`join()` 确保主线程（或其他调用它的线程）在子线程完成其任务之前不会执行 `join()` 之后的代码。这是必要的，因为在子线程中可能进行着一些重要的工作，如清理资源或写入数据，这些工作必须在程序继续执行之前完成。
- **防止竞态条件**：如果主线程在子线程完成之前继续执行并结束程序，子线程可能在没有正确完成其任务的情况下被强制结束，这可能导致数据不一致或资源泄露。
- **资源管理**：在某些情况下，程序需要确保所有子线程在退出前都已经正确地释放了它们所使用的资源。

### 为什么不是通常想象中的非阻塞？

在多线程编程中，非阻塞通常意味着一个线程在等待另一个线程时，还能继续执行其他任务。然而，`join()` 的目的是确保线程的执行顺序和同步，因此它必须阻塞调用它的线程，直到所等待的线程完成。这种阻塞是有意为之的，以确保程序的正确性和稳定性。

问题二：关于 `emplace_back()` 和 `std::thread` 构造函数的调用

`emplace_back()` 是 `std::vector` 的一个成员函数，它使用给定的参数在容器的末尾就地构造一个新元素。当你使用 `emplace_back()` 时，你是直接调用容器内元素类型的构造函数，而不是先构造一个临时对象然后再拷贝或移动它。

### 如何实现的？

当 `emplace_back()` 被调用时，它实际上调用了容器内元素类型的构造函数（在这种情况下是 `std::thread` 的构造函数），并将参数直接传递给它。这个过程是通过模板和函数参数转发实现的，这是 C++11 引入的特性。

### 内部细节

- **模板**：`std::vector` 是一个模板类，它可以存储任何类型的元素。这意味着它必须能够处理各种类型的构造函数。
- **参数转发**：C++11 引入了右值引用（`&&`）和参数转发，使得函数能够接收任意参数并将它们转发给其他函数。在 `emplace_back()` 的实现中，传递给 `emplace_back()` 的参数被完美转发给元素类型的构造函数。
- **就地构造**：`emplace_back()` 直接在容器的内存空间中调用元素的构造函数，这样就不需要先构造一个临时对象再拷贝或移动它。这是通过构造函数的内联调用实现的，提高了效率。

这种机制使得 `emplace_back()` 成为向 `std::vector` 添加元素的高效方式，特别是在涉及到线程时，因为它避免了额外的构造和移动开销。

*/
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
