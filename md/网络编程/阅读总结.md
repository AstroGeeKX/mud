### OnConnect()设置回调函数历程
回调函数OnConnect()的传递路径非常迷惑
- Server -> Connection -> Channel
#### 原因
直线距离是Server到Channel，但是路不通。
但是Server -> Connection和Connection -> Channel，所以有了上面的路径
#### 晚绑定更多理由
回调函数晚绑定的作用，在这里的作用其实没有网上描述得那么夸张，更多是因为对象的构造顺序导致的，
简单来说就是有的对象A已经初始化了，但需要的对象B还没构造出来，所以A提前挂好一个钩子，构造好物品B之后再放上去，完全不至于是复杂问题。
还因为不同的对象拥有不同的解决方案，所以采用回调晚绑定的形式，
还是先创个壳子出来，再利用所谓的拿来主义，让别人干活
函数调用另一个函数是让另一个人干同样的活，回调函数是，让不同的人干不同的活
对于运行时我有一个看法。在库外，也可算作晚绑定，但这时候程序仍然没有运行。


### UpdateChannel(Channel *ch) 调用的详细过程
这个函数现在不是最诡异的了，连带调用了三个类的成员函数，并且函数名是一样的，分别经历了这几个类：
- Channel -> EventLoop -> Epoll
在Channel里调用loop的函数，传入了this，也就是调用的对象自己（调用成员函数必须有一个实例化对象）
（类里面可以访问到自己，有点像三体人在直肠里照镜子看到自己的全身照一样。）

（注意大小写，Epoll是封装类，epoll是Linux底层的IO复用机制）
将ch对象传入EventLoop接着继续传入Epoll，完成epoll兴趣列表的ADD。单个事件结构体ev里面预留的ptr指针正好用于存储ch对象的地址，形成一一绑定的关系。一个ev结构体对象联结一个channel对象。通过这样的方式实现epoll事件处理的高级封装，epoll的行为不指向Epoll，而是指向Channel。
epoll_wait()函数获取触发事件数组列表events的时候，通过遍历的方式，获取数组中每一个元素，即ev结构体对象的ptr指针，将这些对象地址整齐放入vector等容器，最后通过返回值，返回到事件循环进行事件处理。
这样做的目的就是，能按照自己封装的方式来处理就绪事件，再也不用直接接触生涩的epoll底层函数，以及events[]数组等，可以以自己的方式，更方便更整齐地处理就绪事件。变量名更好看、操作更灵活、拓展性更强、代码阅读更清晰。这几大变化。
epoll是底层的机制，进行封装的过程，有点类似生锈的镰刀，在把手缠上一圈运动胶带，使其更好地抓握和使用。


###   int nfds = epoll_wait(epfd_, events_, MAX_EVENTS, timeout) 知识补充
对这四个参数进行详细解析
#### epfd_
一个是ep的文件描述符，类似一个对象实例 （暗示了事件有多个，ep也可以有多个，总数是n * m个
#### events_
第二个参数是一个数组，数组的类型，也就是每一个元素的类型，是一个epoll_event结构体数组，里面的每一个元素都是一个ev事件结构体封装，里面有fd、ptr、events（这里重名有点尴尬，代表事件触发类型）等。epoll_wait执行，等到有事件响应的时候（也就是远程客户端按下回车发送消息的时候），那个远程客户端对应这里的fd，对应的ev事件就会被这个函数进行处理，从兴趣事件列表红黑树上复制一份下来，叫做就绪事件，这一批wait有多少个就绪事件，就有多少个ev元素就复制到events_数组里面，就代表了多少个远程客户端有事件要处理。这时候只需要遍历里面的每一个元素，对每一个就绪事件进行处理（比如读数据再打印），就好了。处理就绪事件的核心，是读取、写入、错误处理这三大操作。
如果当前在遍历每一个就绪事件并处理，整个过程花费10秒中，那么处理完成之后，再次从开头执行epoll_wait()，这时候获取的就绪事件数量就是刚刚过去的10秒钟，若干个远程客户端陆续产生的事件响应，可能是5-6个，也可能是7-8个，总之，就类似暗中操作的感觉。并不会因为刚刚处理就绪事件的过程中，忽略了新的就绪事件，这涉及到了操作系统底层内核的网络协议栈，是自动的，后台的处理，这个过程比用户自己写的代码看起来要高级得多。当前写的代码让人看起来就是，有些步骤错过了就错过了，但是系统内核不是这样，这两者对比，就给人一种错误引导，认为系统内核也是很白痴的样子，不敢相信内核协议栈居然那么高级和自动。
#### MAX_EVENTS
最大就绪事件数量，这个有点重复设置，在创建events_数组的时候就是这么写的：
```c++
            struct epoll_event *events; // 类型相符 指针可以指向数组
            events_ = new epoll_event[MAX_EVENTS];
```
已经指明了数组的大小，也就是最大的就绪事件数量，但是奈何数组不是很智能，还需要再指明一次数组大小
#### timeout
timeout是超时设置。超时设置的时间概念我一直没搞懂，可能是因为目前还没有认识到，时间设置的重要性，也许是因为代码还没有体现出来。-1代表永远等待，当然用户可以Ctrl + c退出程序。
时间过了就会报错什么的，就会抛出问题。假想用户对问题进行这样的处理，设置等待时间10秒，结束之后，抛出错误，在命令行终端打印“这个10秒钟没有任何客户端的就绪事件响应”，然后再让代码继续进行下一回合的等待，继续反复执行epoll_wait()。可以看出，错误，并不意味着程序退出，也可能意味着打印一行信息之后继续重试。
当前阶段的学习认知不到错误处理是很正常的，因为正常情况下错误处理往往意味这退出程序，当然想象不到还可以继续反复执行。说白了错误处理在无关紧要的阶段，更像是一种看门狗，到了给定时间还没有事件响应的话，就打印信息，再继续反复执行代码，这种错误，几乎不影响程序的正常运行。是“错误”这个词给人一种结束程序的误导。
估计是翻译有问题，这不叫错误。
这叫代码的没有预期的行为，出乎预料，但又在情理之中。欧亨利代码片段
真正的异常，应该是强行使程序员修复问题的那种，而不是这种明确了解决方案和执行流程的东西。这叫条件分支。
ai建议能不抛出异常的，尽量用条件分支来解决。

### ev.data.fd = fd 其实有点鸡肋
本以为，这里的fd是为了指定目标套接字文件描述符，但是发现函数参数里也有，看起来重复了
                        epoll_ctl(epfd_, EPOLL_CTL_ADD, fd, &ev)
查了资料才发现，真正设置epoll兴趣列表的fd是函数第三个参数的fd。而结构体对象里ev.data.fd的设置，是为了备用，跟epoll没有直接关联。但是，ev.events成员跟epoll有直接关联，这两者不一样，使得ev结构体看起来很别扭，应该是早期epoll的遗留产物。
- 从epoll的功能核心来看，可以认为data成员是不必要的
epoll_event结构体有两个主要成员：
events: 
这个成员是一个unsigned int类型，用于指定感兴趣的事件类型，如EPOLLIN（可读事件）、EPOLLOUT（可写事件）等。这是epoll监测文件描述符变化的关键信息。
data: 
正如我们之前讨论的，这主要用于携带与事件相关的附加信息，并非epoll必需。但在事件发生后，可以有用，用于携带相关信息以备用。
```c++
struct epoll_event {
    uint32_t events;  // epoll 事件类型，包括可读，可写等
    epoll_data_t data; // 用户数据，可以是一个指针或文件描述符等
};

// 这个联合体专门用来存放用户备用数据，比如自身fd和指针等，还预留了32和64位整型变量
// 但放到现代编程上看，真的没什么必要，因为手搓结构体应该是基本操作了
typedef union epoll_data {
    void *ptr;
    int fd; // 实际上这fd也是预留的变量，没有什么实际用途
    uint32_t u32;
    uint64_t u64;
} epoll_data_t; // 很无聊的一个别名，我觉得epoll_data就很不错
```
